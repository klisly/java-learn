计数排序

当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。

由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。

算法的步骤如下：

找出待排序的数组中最大和最小的元素
统计数组中每个值为i的元素出现的次数，存入数组C的第i项
对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
贴上代码：
[html] view plain copy
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//对于排序的关键字范围，一定是0-99
#define NUM_RANGE (100)

void print_arr(int *arr, int n)
{
       int i;
       for(i=0; i<n; i++){
               if(!i){
                       printf("%d", arr[i]);
               }else{
                       printf(" %d", arr[i]);
               }
       }
       printf("\n");
}

/*
算法的步骤如下：
    1.找出待排序的数组中最大和最小的元素
    2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项
    3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
    4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
*/

void counting_sort(int *ini_arr, int *sorted_arr, int n)
{
       int *count_arr = (int *)malloc(sizeof(int) * NUM_RANGE);
       int i, j, k;

       //统计数组中，每个元素出现的次数
       for(k=0; k<NUM_RANGE; k++){
               count_arr[k] = 0;
       }

       for(i=0; i<n; i++){
               count_arr[ini_arr[i]]++;
       }


       for(k=1; k<NUM_RANGE; k++){
               count_arr[k] += count_arr[k-1];
       }

       for(j=n-1 ; j>=0; j--){
           int elem = ini_arr[j];
           int index = count_arr[elem]-1;
           sorted_arr[index] = elem;
           count_arr[elem]--;
       }
       free(count_arr);
}


int main(int argc, char* argv[])
{
       int n;
       if(argc < 2){
               n = 10;
       }else{
               n = atoi(argv[1]);
       }
       int i;
       int *arr = (int *)malloc(sizeof(int) * n);
       int *sorted_arr = (int *)malloc(sizeof(int) *n);
       srand(time(0));


       for(i=0; i<n; i++){
               arr[i] = rand() % NUM_RANGE;
       }

       printf("ini_array: ");
       print_arr(arr, n);
       counting_sort(arr, sorted_arr, n);
       printf("sorted_array: ");
       print_arr(sorted_arr, n);
       free(arr);
       free(sorted_arr);
       return 0;
}

 桶排序：http://blog.sina.com.cn/s/blog_667739ba0100veth.html

桶排序的基本思想
假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。
假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。
桶排序代价分析
桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。

对N个关键字进行桶排序的时间复杂度分为两个部分：
(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。
(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。

很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：
(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。
(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。

对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：
O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。

总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
我个人还有一个感受：在查找算法中，基于比较的查找算法最好的时间复杂度也是O(logN)。比如折半查找、平衡二叉树、红黑树等。但是Hash表却有O(C)线性级别的查找效率(不冲突情况下查找效率达到O(1))。大家好好体会一下：Hash表的思想和桶排序是不是有一曲同工之妙呢?
基数排序
上面的问题是多关键字的排序，但单关键字也仍然可以使用这种方式。
比如字符串“abcd” “aesc” "dwsc" "rews"就可以把每个字符看成一个关键字。另外还有整数 425、321、235、432也可以每个位上的数字为一个关键字。

基数排序的思想就是将待排数据中的每组关键字依次进行桶分配。比如下面的待排序列：
278、109、063、930、589、184、505、269、008、083
我们将每个数值的个位，十位，百位分成三个关键字： 278 -> k1(个位)=8 ，k2(十位)=7 ，k3=(百位)=2。
然后从最低位个位开始(从最次关键字开始)，对所有数据的k1关键字进行桶分配(因为，每个数字都是 0-9的，因此桶大小为10)，再依次输出桶中的数据得到下面的序列。
930、063、083、184、505、278、008、109、589、269
再对上面的序列接着进行针对k2的桶分配，输出序列为：
505、008、109、930、063、269、278、083、184、589
最后针对k3的桶分配，输出序列为：
008、063、083、109、184、269、278、505、589、930

性能分析
很明显，基数排序的性能比桶排序要略差。每一次关键字的桶分配都需要O(N)的时间复杂度，而且分配之后得到新的关键字序列又需要O(N)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2N) ，当然d要远远小于N，因此基本上还是线性级别的。基数排序的空间复杂度为O(N+M)，其中M为桶的数量。一般来说N>>M，因此额外空间需要大概N个左右。

但是，对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，桶内多个数据必须进行基于比较操作的排序。因此，在实际应用中，基数排序的应用范围更加广泛。